# 功能配额系统设计方案 (Feature Quota System Design)

## 1. 概述

本文档概述了服务端功能配额系统（Feature Gating & Quota Management）的技术设计。我们将不再在前端硬编码限制，而是由后端作为“单一事实来源 (Source of Truth)”来管理功能限制和使用情况追踪。

## 2. 数据库结构 (Database Schema) (已完成)

我们将引入两张新表来分别管理“配置”和“用户状态”。

### 2.1 功能配置表 (`feature_limits`)

定义每个订阅等级 (Tier) 的规则和限制。这允许我们在不更新 App 的情况下动态调整策略。

```sql
CREATE TABLE feature_limits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tier TEXT NOT NULL CHECK (tier IN ('free', 'plus', 'pro')),
    feature_key TEXT NOT NULL,  -- 例如 'daily_conversation', 'voice_input', 'custom_scenarios'

    -- 配额数值: -1 代表无限，0 代表不可用，正整数代表具体限制数量
    quota_limit INTEGER NOT NULL DEFAULT 0,

    -- 刷新策略:
    -- 'daily': 每天 00:00 UTC 重置 (如 daily_conversation)
    -- 'static': 从不重置，终身累计 (如 custom_scenarios)
    refresh_period TEXT NOT NULL DEFAULT 'daily' CHECK (refresh_period IN ('daily', 'static')),

    -- 版本控制字段 (支持配额调整和限时活动)
    effective_from TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    effective_to TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,

    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- 同一时间段内，同一 tier + feature_key 只能有一个活跃配置
    CONSTRAINT unique_active_config UNIQUE (tier, feature_key, effective_from)
);
```

### 2.2 用户用量状态表 (`user_feature_usage`)

使用 **JSONB** 格式存储，确保每个用户在数据库中**只占一行**。

```sql
CREATE TABLE user_feature_usage (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,

    -- 存储所有功能的用量状态
    -- Key: feature_key
    -- Value:
    -- {
    --   "count": int,         // 当前周期已用量
    --   "period": string,     // 周期标识 ("YYYY-MM-DD" for daily, "lifetime" for static)
    --   "updated_at": bigint  // 时间戳 (ms)
    -- }
    --
    -- 示例:
    -- {
    --   "daily_conversation": {
    --     "count": 45,
    --     "period": "2026-01-25",        // daily 类型: 每天重置
    --     "updated_at": 1706164800000
    --   },
    --   "custom_scenarios": {
    --     "count": 8,
    --     "period": "lifetime",          // static 类型: 永久累计，不重置
    --     "updated_at": 1705800000000
    --   }
    -- }
    usage_data JSONB DEFAULT '{}'::jsonb,

    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

## 3. 业务逻辑 (服务端)

### 3.1 初始化 (Trigger) (已完成)

当新用户注册时，我们需要初始化他们的用量记录。我们可以使用 `auth.users` 上的数据库触发器来实现。

```sql
-- 触发器函数
CREATE OR REPLACE FUNCTION handle_new_user_quotas()
RETURNS TRIGGER AS $$
BEGIN
  -- 插入一行空记录，确保后续可以直接 Update
  INSERT INTO user_feature_usage (user_id, usage_data)
  VALUES (NEW.id, '{}'::jsonb);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 触发器定义
CREATE TRIGGER on_auth_user_created_quotas
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user_quotas();
```

### 3.2 获取配额状态 (RPC) (已完成)

前端需要获取“限制 vs 用量”的统一视图。我们使用 Postgres 函数 (RPC) 动态计算，并在读取时处理“每日重置”逻辑。

**逻辑:**

- 输入: `user_id` (默认为当前用户)
- 输出: 功能列表。
- **解析逻辑**:
  - 从 `feature_limits` 获取所有功能定义。
  - 从 `user_feature_usage.usage_data` 中读取对应的 JSON 对象。
  - 检查 date: 如果 JSON 中的 date 不是今天 (UTC)，则视 `used` 为 0。
  - 否则使用 JSON 中的 `used`。

```sql
CREATE OR REPLACE FUNCTION get_user_quota_status()
RETURNS TABLE (
  feature_key TEXT,
  used_count INT,
  quota_limit INT,
  remaining INT,
  refresh_period TEXT
) AS $$
DECLARE
  current_tier TEXT;
  current_date TEXT;
  usage_json JSONB;
BEGIN
  -- 1. 获取用户当前订阅等级 (默认 'free')
  SELECT COALESCE(us.tier, 'free')
  INTO current_tier
  FROM user_subscriptions us
  WHERE us.user_id = auth.uid()
  LIMIT 1;

  -- 如果没有订阅记录，默认为 free
  IF current_tier IS NULL THEN
    current_tier := 'free';
  END IF;

  -- 2. 获取今天的日期 (UTC)
  current_date := to_char(NOW() AT TIME ZONE 'UTC', 'YYYY-MM-DD');

  -- 3. 获取用户的 usage_data
  SELECT COALESCE(ufu.usage_data, '{}'::jsonb)
  INTO usage_json
  FROM user_feature_usage ufu
  WHERE ufu.user_id = auth.uid();

  -- 如果用户没有记录，初始化为空 JSONB
  IF usage_json IS NULL THEN
    usage_json := '{}'::jsonb;
  END IF;

  -- 4. 返回所有功能的配额状态 (根据当前活跃配置)
  RETURN QUERY
  SELECT
    fl.feature_key,
    -- 计算已用量：检查 period 是否匹配
    CASE
      -- Daily 类型：如果日期不匹配，视为新的一天，返回 0
      WHEN fl.refresh_period = 'daily'
           AND (usage_json -> fl.feature_key ->> 'period') != current_date
      THEN 0
      -- Static 类型 或 日期匹配：返回实际 count
      ELSE COALESCE((usage_json -> fl.feature_key ->> 'count')::INT, 0)
    END AS used_count,
    fl.quota_limit,
    -- 计算剩余量
    CASE
      WHEN fl.quota_limit = -1 THEN -1  -- 无限制
      WHEN fl.refresh_period = 'daily'
           AND (usage_json -> fl.feature_key ->> 'period') != current_date
      THEN fl.quota_limit  -- 新的一天，剩余 = 总额
      ELSE GREATEST(0, fl.quota_limit - COALESCE((usage_json -> fl.feature_key ->> 'count')::INT, 0))
    END AS remaining,
    fl.refresh_period
  FROM feature_limits fl
  WHERE fl.tier = current_tier
    AND fl.is_active = true  -- 只查询活跃的配置
    AND (fl.effective_to IS NULL OR fl.effective_to > NOW());  -- 未过期
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3.3 记录用量 (RPC) (已完成)

为了安全地增加用量，前端通过调用安全的 RPC 函数而不是直接更新表。

**逻辑:**

- 输入: `feature_key`, `amount` (默认 1)
- 返回: `JSONB` - `{ "success": boolean, "remaining": int, "message": string }`
- 步骤:
  1. 获取当前 UTC 日期字符串或 "lifetime"（根据 refresh_period）。
  2. 读取配额限制（从 `feature_limits`）。
  3. 读取用户当前 `usage_data -> feature_key`。
  4. 比较日期/period:
     - 记录 period == 当前 period: `new_count = old_count + amount`
     - 记录 period != 当前 period (或不存在): `new_count = amount`
  5. **超额检查**: 如果 `quota_limit != -1 AND new_count > quota_limit`，返回失败。
  6. 使用 `jsonb_set` 更新单一 Key，保持其他 Feature 数据不变。
  7. 返回成功结果和剩余配额。

```sql
CREATE OR REPLACE FUNCTION track_feature_usage(
  feature TEXT,
  amount INT DEFAULT 1
)
RETURNS JSONB AS $$
DECLARE
  current_period TEXT;
  usage_json JSONB;
  current_count INT;
  quota_limit INT;
  refresh_period TEXT;
  new_count INT;
  remaining_quota INT;
  current_tier TEXT;
BEGIN
  -- 1. 获取用户当前订阅等级
  SELECT COALESCE(us.tier, 'free')
  INTO current_tier
  FROM user_subscriptions us
  WHERE us.user_id = auth.uid()
  LIMIT 1;

  IF current_tier IS NULL THEN
    current_tier := 'free';
  END IF;

  -- 2. 获取配额限制和刷新策略
  SELECT fl.quota_limit, fl.refresh_period
  INTO quota_limit, refresh_period
  FROM feature_limits fl
  WHERE fl.tier = current_tier
    AND fl.feature_key = feature
    AND fl.is_active = true
    AND (fl.effective_to IS NULL OR fl.effective_to > NOW())
  LIMIT 1;

  -- 如果找不到配置，返回错误
  IF quota_limit IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'remaining', 0,
      'message', 'Feature configuration not found'
    );
  END IF;

  -- 3. 确定当前 period
  IF refresh_period = 'daily' THEN
    current_period := to_char(NOW() AT TIME ZONE 'UTC', 'YYYY-MM-DD');
  ELSE
    current_period := 'lifetime';  -- static 类型
  END IF;

  -- 4. 获取当前用量数据
  SELECT COALESCE(ufu.usage_data, '{}'::jsonb)
  INTO usage_json
  FROM user_feature_usage ufu
  WHERE ufu.user_id = auth.uid();

  IF usage_json IS NULL THEN
    usage_json := '{}'::jsonb;
  END IF;

  -- 5. 计算新用量
  IF (usage_json -> feature ->> 'period') = current_period THEN
    -- 同一周期内，累加
    current_count := COALESCE((usage_json -> feature ->> 'count')::INT, 0);
    new_count := current_count + amount;
  ELSE
    -- 新周期（或首次使用），从 amount 开始
    new_count := amount;
  END IF;

  -- 6. 超额检查
  IF quota_limit != -1 AND new_count > quota_limit THEN
    RETURN jsonb_build_object(
      'success', false,
      'remaining', 0,
      'message', 'Quota exceeded'
    );
  END IF;

  -- 7. 更新记录
  UPDATE user_feature_usage
  SET
    usage_data = jsonb_set(
      usage_data,
      ARRAY[feature],
      jsonb_build_object(
        'count', new_count,
        'period', current_period,
        'updated_at', EXTRACT(EPOCH FROM NOW() AT TIME ZONE 'UTC')::BIGINT * 1000
      )
    ),
    updated_at = NOW()
  WHERE user_id = auth.uid();

  -- 如果用户记录不存在，插入一条新记录
  IF NOT FOUND THEN
    INSERT INTO user_feature_usage (user_id, usage_data)
    VALUES (
      auth.uid(),
      jsonb_build_object(
        feature,
        jsonb_build_object(
          'count', new_count,
          'period', current_period,
          'updated_at', EXTRACT(EPOCH FROM NOW() AT TIME ZONE 'UTC')::BIGINT * 1000
        )
      )
    );
  END IF;

  -- 8. 计算剩余配额
  IF quota_limit = -1 THEN
    remaining_quota := -1;
  ELSE
    remaining_quota := quota_limit - new_count;
  END IF;

  -- 9. 返回成功结果
  RETURN jsonb_build_object(
    'success', true,
    'remaining', remaining_quota,
    'message', 'Usage tracked successfully'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3.4 配额重置机制 (Quota Reset Mechanism)

本系统采用 **“惰性重置 (Lazy Reset)”** 策略，而非传统的 Cron Job 主动重置。

**核心原理**:
我们不通过定时的后台任务来清零所有用户的配额，而是在用户**访问**（读取或写入用量）的那一刻，动态判断数据是否过期。

**工作流程**:

1.  **用户不活跃时**:
    - 即使到了 00:00，数据库中的数据保持不变（例如 `count: 10`, `period: "2026-01-24"`）。
    - **优势**: 节省大量数据库资源，避免处理无效数据。

2.  **用户调用时 (Lazy Check)**:
    - 用户发起 `track_feature_usage`。
    - 逻辑层获取 `Current Date (UTC)` ("2026-01-25")。
    - 逻辑层对比数据库中的 `period` ("2026-01-24")。
    - 发现 `period != Current Date`，判定为**已过期**。
    - 直接将新记录视为从 0 开始累计（即本次写入 `count = amount`），并将 `period` 更新为今天。

这种机制通过在业务逻辑中简单的字符串比对，替代了维护复杂且昂贵的系统级定时任务。

## 4. 安全性与 RLS (已完成)

1.  **`feature_limits`**:
    - **Select**: 公开 (已认证用户可读取限制)。
    - **Insert/Update/Delete**: 仅限服务角色 (Service Role) 或管理员。
2.  **`user_feature_usage`**:
    - **Select**: 用户只能查看自己的用量 (`auth.uid() = user_id`)。
    - **Update**: **全员禁止**。更新必须通过 `track_feature_usage` RPC 进行，以确保逻辑一致性 (重置日期、检查上限)。

## 5. 前端集成计划 (部分已完成)

### 5.1 性能优化策略 (Optimistic UI)

为了避免每次操作都阻塞等待网络请求，前端将采用 **“本地乐观检查 + 异步同步”** 策略。

1.  **初始化与恢复 (Init & Resume)**:
    - App 启动或**从后台返回 (`onResumed`)** 时，调用 `get_user_quota_status` 拉取最新状态。
    - 总是先加载本地缓存到内存，确保 UI 可交互。
2.  **本地检查 (Check)**:
    - 用户点击功能时，`FeatureGate` **仅检查本地缓存**。
    - **UTC Reset Check**: 检查前会比较缓存中的 `period_date` 和当前 UTC 日期，如果跨天则临时视为 0 用量。
    - 如果 `cache.count < cache.limit`，立即返回 `true`。
3.  **异步同步 (Async Sync)**:
    - 在执行业务逻辑的同时，前端后台**异步**调用 `track_feature_usage` RPC。
    - **Conflict Handling**:
      - 如果 RPC 成功：(静默)。
      - 如果 RPC 失败 (Network Error)：保留本地乐观状态 (Fail-Open)。
      - 如果 RPC 返回“已超额 (Exceeded)”：**强制更新**本地状态为“已耗尽”，并在下次操作时拦截。
4.  **兜底防护 (Hard Guard)**:
    - 真正的硬性拦截由后端的业务 API (Cloudflare Worker) 实现。API 在执行昂贵操作前会复核配额。前端检查主要用于**用户体验优化**。

### 5.1.1 Gate 自动扣费策略 (Auto-consume in Gate) ✅

`FeatureGate.performWithFeatureCheck` 方法在检查通过后，应**自动调用** `trackUsage` 进行用量记录，而非依赖业务代码手动调用。

**设计决策理由**:

| 考量维度       | Gate 自动扣费     | 业务手动扣费                    |
| -------------- | ----------------- | ------------------------------- |
| **遗漏风险**   | ✅ 不可能遗漏     | ❌ 高风险，每个调用点都可能忘记 |
| **代码一致性** | ✅ 集中管理       | ❌ 分散在各业务代码中           |
| **开发体验**   | ✅ 业务代码零负担 | ❌ 需记住额外调用               |
| **误扣费**     | ⚠️ 需规范调用时机 | ✅ 业务控制精准                 |

**核心实现**:

```dart
Future<bool> performWithFeatureCheck(...) async {
  // 1. Check Hard Gates (hasAccess)
  // 2. Check Quota (canUse)

  // 3. ✅ Auto-track usage BEFORE granting access
  await _usageService.trackUsage(feature);

  // 4. Grant access
  onGranted?.call();
  return true;
}
```

**调用时机原则 (Critical)**:

> ⚠️ **Gate 检查必须放在"不可逆操作"的触发点，而非"可取消流程"的入口**

| 场景           | ❌ 错误做法               | ✅ 正确做法                        |
| -------------- | ------------------------- | ---------------------------------- |
| 发送消息       | -                         | 点击发送按钮时检查 (点击即发送)    |
| 创建自定义场景 | 点击 FAB 打开对话框时检查 | 对话框内"确认创建"按钮时检查       |
| 语法分析       | 点击菜单项时检查          | 菜单项点击后直接发起分析，同时检查 |

**误扣费规避**:

对于 `static` (终身) 类型的配额（如 `customScenarios`），误扣一次的影响远大于 `daily` 类型。因此：

- `daily` 类型：调用时机要求相对宽松
- `static` 类型：**必须**严格遵循"不可逆触发点"原则

### 5.1.2 订阅自适应同步 (Subscription Adaptive Sync) (已完成)

为了确保用户在购买或续费后立即获得最新的配额，系统实现了**订阅状态自动同步机制**：

1.  **监听变更 (Listening)**:
    - `UsageServiceImpl` 在初始化时监听 `RevenueCatService`。
    - 仅在 `currentTier` 发生实际变化时触发（忽略无关的 Offerings 更新）。

2.  **防抖机制 (Debouncing)**:
    - 引入 500ms 防抖计时器。
    - 合并短时间内连续的状态变化（如购买成功后的一系列回调），减少不必要的网络请求。

3.  **智能重试 (Smart Retry)**:
    - **问题**: RevenueCat SDK 的本地回调通常比后端 Webhook 更新数据库要快。
    - **策略**: 当收到前端 Tier 变更通知后，如果 `syncFromServer()` 返回的后端 Tier 仍旧是旧的：
      - 自动触发重试逻辑。
      - **Max Retries**: 3 次。
      - **Delay**: 每次间隔 2 秒。
    - 这确保了即使 webhook 有几秒钟的延迟，前端最终也能同步到正确的配额限制。

### 5.2 开发任务

1.  ✅ **模型 (Models)**: 创建配额状态模型。
    - `lib/features/subscription/domain/models/feature_quota_status.dart`
    - 包含 `FeatureQuotaStatus`、`TrackUsageResult`、`FeatureQuotaCache`
2.  ✅ **服务接口 (Interface)**: 扩展 `UsageService` 接口。
    - `lib/features/subscription/domain/services/usage_service.dart`
    - 新增：`getQuotaStatus()`、`canUse()`、`trackUsage()`、`syncFromServer()`
3.  ✅ **缓存 Provider**: 创建 `FeatureQuotaCacheProvider`。
    - `lib/core/cache/providers/feature_quota_cache_provider.dart`
    - 实现 `CacheProvider` 接口，支持惰性每日重置
4.  ✅ **服务实现 (Service)**: 创建 `UsageServiceImpl`。
    - `lib/features/subscription/data/services/supabase_usage_service.dart`
    - 实现缓存 + 异步同步逻辑、`WidgetsBindingObserver` 生命周期监听
5.  ✅ **FeatureGate 自动扣费**: 在 `performWithFeatureCheck` 中集成 `trackUsage`。
    - `lib/features/subscription/presentation/feature_gate.dart`
    - 在检查通过后、`onGranted` 回调前，调用 `_usageService.trackUsage(feature)`
    - 确保扣费为异步操作，不阻塞 UI（使用 `unawaited`）
6.  ⬜ **DI 集成**: 在 App 初始化时注册 `UsageServiceImpl`。
    - 在 `AppBootstrap` 或 `AppInitializer` 中初始化
    - 注册 `FeatureQuotaCacheProvider` 到 `CacheManager`
7.  ✅ **订阅变更联动**: 当 Tier 变化时刷新配额缓存。
    - 监听 `RevenueCatService` 的订阅状态变化
    - 实现防抖 (Debounce) 和重试 (Retry) 机制
    - 调用 `usageService.syncFromServer()` 强制刷新
8.  ✅ **调用点修正**: 修正 `static` 类型配额的 Gate 调用位置。
    - `customScenarios`: 将 Gate 从 `home_screen.dart` FAB 移至 `custom_scene_dialog.dart` 的 "Generate" 按钮
    - 审查所有 `performWithFeatureCheck` 调用点，确保符合"不可逆触发点"原则

## 6. 迁移步骤 (已完成)

1.  **创建迁移 SQL**:
    - 创建表。
    - 设置 RLS。
    - 创建函数 (RPCs) 和触发器。
    - **插入初始配额配置 (Seed Data)**。
    - **为现有用户初始化配额记录**。
2.  **应用迁移**: 运行 `supabase db reset` 或推送迁移。
3.  **前端更新**: 切换 `UsageService` 的实现。

### 6.1 初始化数据 (Seed Data) (已完成)

迁移 SQL 中需要包含以下初始配额配置：

```sql
-- ============================================
-- 插入默认配额配置 (基于 pricing_strategy.md 2026-01-28 版本)
-- ============================================
INSERT INTO feature_limits (tier, feature_key, quota_limit, refresh_period, is_active) VALUES
-- Free tier
('free', 'daily_conversation', 3, 'daily', true),
('free', 'voice_input', 3, 'daily', true),
('free', 'speech_assessment', 3, 'daily', true),
('free', 'word_pronunciation', 10, 'daily', true),
('free', 'grammar_analysis', 3, 'daily', true),
('free', 'tts_speak', 3, 'daily', true),
('free', 'custom_scenarios', 0, 'static', true),        -- Free 用户不能创建
('free', 'pitch_analysis', 0, 'daily', true),           -- Free 用户不可用

-- Plus tier
('plus', 'daily_conversation', -1, 'daily', true),      -- 无限制
('plus', 'voice_input', -1, 'daily', true),             -- 无限制
('plus', 'speech_assessment', 20, 'daily', true),
('plus', 'word_pronunciation', -1, 'static', true),     -- 无限制
('plus', 'grammar_analysis', -1, 'daily', true),        -- 无限制
('plus', 'tts_speak', 100, 'daily', true),
('plus', 'custom_scenarios', 30, 'static', true),       -- 终身 30 个
('plus', 'pitch_analysis', -1, 'daily', true),          -- 无限制

-- Pro tier
('pro', 'daily_conversation', -1, 'daily', true),       -- 无限制
('pro', 'voice_input', -1, 'daily', true),              -- 无限制
('pro', 'speech_assessment', 100, 'daily', true),
('pro', 'word_pronunciation', -1, 'static', true),      -- 无限制
('pro', 'grammar_analysis', -1, 'daily', true),         -- 无限制
('pro', 'tts_speak', -1, 'daily', true),                -- 无限制
('pro', 'custom_scenarios', -1, 'static', true),        -- 无限制
('pro', 'pitch_analysis', -1, 'daily', true);           -- 无限制
```

### 6.2 现有用户初始化 (已完成)

为已存在的用户创建配额记录（触发器只对新用户生效）：

```sql
-- ============================================
-- 为现有用户初始化配额记录
-- ============================================
INSERT INTO user_feature_usage (user_id, usage_data)
SELECT id, '{}'::jsonb
FROM auth.users
WHERE NOT EXISTS (
  SELECT 1 FROM user_feature_usage
  WHERE user_feature_usage.user_id = auth.users.id
);
```

## 7. 配额调整更新 (2026-01-28)

根据最新的 [定价策略](pricing_strategy.md)，我们需要更新 Plus 和 Pro 用户的配额配置，并引入 `pitch_analysis` 功能。

**变更摘要**:

1.  **Plus 用户**:
    - `daily_conversation` (AI 对话), `voice_input` (语音输入), `grammar_analysis` (语法分析) 从 20/天 提升为 **无限** (-1)。
    - `tts_speak` (TTS) 从 20/天 提升为 **100/天**。
    - `custom_scenarios` (自定义场景) 从 10 个 提升为 **30 个**。
2.  **Pro 用户**:
    - `daily_conversation`, `voice_input`, `grammar_analysis`, `tts_speak`, `custom_scenarios` 均为 **无限** (-1)。
3.  **新增功能**:
    - `pitch_analysis` (音高对比分析): Free (0 不可用), Plus (无限), Pro (无限)。
4.  **保持不变**:
    - `speech_assessment` (发音评估): Free (3/天), Plus (20/天), Pro (100/天) — 维持原配额。
    - `word_pronunciation` (单词发音): Free (10/天), Plus (无限), Pro (无限) — 维持原配额。

### 7.1 更新 SQL

运行以下 SQL 以更新现有配置和插入新功能限制：

```sql
-- ============================================
-- 1. 更新 Plus 和 Pro 用户额度 (2026-01-28)
-- ============================================

-- Check existing limits before update if needed
-- SELECT * FROM feature_limits;

-- Update Plus Tier
UPDATE feature_limits SET quota_limit = -1 WHERE tier = 'plus' AND feature_key IN ('daily_conversation', 'voice_input', 'grammar_analysis');
UPDATE feature_limits SET quota_limit = 100 WHERE tier = 'plus' AND feature_key = 'tts_speak';
UPDATE feature_limits SET quota_limit = 30 WHERE tier = 'plus' AND feature_key = 'custom_scenarios';

-- Update Pro Tier
UPDATE feature_limits SET quota_limit = -1 WHERE tier = 'pro' AND feature_key IN ('daily_conversation', 'voice_input', 'grammar_analysis', 'tts_speak', 'custom_scenarios');

-- ============================================
-- 2. 插入新功能: 音高分析 (pitch_analysis)
-- ============================================
INSERT INTO feature_limits (tier, feature_key, quota_limit, refresh_period, is_active) VALUES
('free', 'pitch_analysis', 0, 'daily', true),
('plus', 'pitch_analysis', -1, 'daily', true),
('pro', 'pitch_analysis', -1, 'daily', true)
ON CONFLICT (tier, feature_key) DO UPDATE
SET quota_limit = EXCLUDED.quota_limit;
```

## 8. 运维指南 (Maintenance Guide)

本章节旨在指导未来的配额调整和新功能接入。

### 8.1 调整现有配额 (Quota Updates)

**数据库 (Source of Truth)**
配额配置完全由后端数据库 `feature_limits` 表控制。调整配额**不需要**发布前端新版本，只需执行 SQL 更新即可即时生效（用户重启 App 或缓存过期后同步）。

SQL 模板：

```sql
-- 将 Plus 用户的 TTS 额度调整为 200/天
UPDATE feature_limits
SET quota_limit = 200
WHERE tier = 'plus' AND feature_key = 'tts_speak';

-- 将 Free 用户的对话改为无限 (测试促销)
UPDATE feature_limits
SET quota_limit = -1
WHERE tier = 'free' AND feature_key = 'daily_conversation';
```

**前端代码 (UsageService)**
前端 `usage_service_impl.dart` 中有一个 `_getFallbackLimit` 方法。此方法仅在**用户离线**或**冷启动尚未拉取到配置**时提供兜底值。

- **建议**: 每次大幅调整配额策略时，同步更新此方法中的硬编码值，以保证离线体验的一致性。
- **非强制**: 如果不更新，仅仅是离线时显示的额度是旧的，联网后会立即修正为数据库中的新值。

### 8.2 接入新功能 (Adding New Features)

接入一个新的受限功能（例如：AI 写作批改 `ai_writing`）的完整流程：

1.  **后端配置 (Database)**
    在 `feature_limits` 表中为该功能插入所有 Tier 的配置。

    ```sql
    INSERT INTO feature_limits (tier, feature_key, quota_limit, refresh_period, is_active) VALUES
    ('free', 'ai_writing', 3, 'daily', true),
    ('plus', 'ai_writing', 50, 'daily', true),
    ('pro', 'ai_writing', -1, 'daily', true);
    ```

2.  **前端定义 (PaidFeature Enum)**
    在 `lib/features/subscription/domain/models/paid_feature.dart` 中添加枚举值。

    ```dart
    enum PaidFeature {
      ...
      aiWriting,
    }
    ```

3.  **前端映射 (UsageService)**
    在 `usage_service_impl.dart` 中更新映射逻辑：
    - `_getFeatureKey`: 添加 `PaidFeature.aiWriting => 'ai_writing'` 的映射。
    - `_getFallbackLimit`: 添加默认兜底值。

4.  **UI 接入 (FeatureGate)**
    在功能入口处使用 `FeatureGate` 进行拦截。
    ```dart
    FeatureGate(
      feature: PaidFeature.aiWriting,
      child: WritingButton(...),
    )
    ```

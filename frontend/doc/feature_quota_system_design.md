# 功能配额系统设计方案 (Feature Quota System Design)

## 1. 概述

本文档概述了服务端功能配额系统（Feature Gating & Quota Management）的技术设计。我们将不再在前端硬编码限制，而是由后端作为“单一事实来源 (Source of Truth)”来管理功能限制和使用情况追踪。

## 2. 数据库结构 (Database Schema)

我们将引入两张新表来分别管理“配置”和“用户状态”。

### 2.1 功能配置表 (`feature_limits`)

定义每个订阅等级 (Tier) 的规则和限制。这允许我们在不更新 App 的情况下动态调整策略。

```sql
CREATE TABLE feature_limits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tier TEXT NOT NULL CHECK (tier IN ('free', 'plus', 'pro')),
    feature_key TEXT NOT NULL,  -- 例如 'daily_conversation', 'voice_input'

    -- 配额数值: -1 代表无限，0 代表不可用，正整数代表具体限制数量
    quota_limit INTEGER NOT NULL DEFAULT 0,

    -- 刷新策略:
    -- 'daily': 每天 00:00 UTC 重置
    -- 'static': 从不重置 (例如总存储空间限制)
    refresh_period TEXT NOT NULL DEFAULT 'daily' CHECK (refresh_period IN ('daily', 'static')),

    created_at TIMESTAMPTZ DEFAULT NOW(),

    UNIQUE(tier, feature_key)
);
```

### 2.2 用户用量状态表 (`user_feature_usage`)

使用 **JSONB** 格式存储，确保每个用户在数据库中**只占一行**。

```sql
CREATE TABLE user_feature_usage (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,

    -- 存储所有功能的用量状态
    -- Key: feature_key
    -- Value:
    -- {
    --   "count": int,         // 当前周期已用量
    --   "period": string,     // 周期标识 ("YYYY-MM-DD", "YYYY-MM", "lifetime")
    --   "updated_at": bigint  // 时间戳 (ms)
    -- }
    --
    -- 示例:
    -- {
    --   "daily_conversation": {
    --     "count": 45,
    --     "period": "2026-01-25",
    --     "updated_at": 1706164800000
    --   },
    --   "custom_scenarios": {
    --     "count": 8,
    --     "period": "lifetime",
    --     "updated_at": 1705800000000
    --   }
    -- }
    usage_data JSONB DEFAULT '{}'::jsonb,

    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

## 3. 业务逻辑 (服务端)

### 3.1 初始化 (Trigger)

当新用户注册时，我们需要初始化他们的用量记录。我们可以使用 `auth.users` 上的数据库触发器来实现。

```sql
-- 触发器函数
CREATE OR REPLACE FUNCTION handle_new_user_quotas()
RETURNS TRIGGER AS $$
BEGIN
  -- 插入一行空记录，确保后续可以直接 Update
  INSERT INTO user_feature_usage (user_id, usage_data)
  VALUES (NEW.id, '{}'::jsonb);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 触发器定义
CREATE TRIGGER on_auth_user_created_quotas
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user_quotas();
```

### 3.2 获取配额状态 (RPC)

前端需要获取“限制 vs 用量”的统一视图。我们使用 Postgres 函数 (RPC) 动态计算，并在读取时处理“每日重置”逻辑。

**逻辑:**

- 输入: `user_id` (默认为当前用户)
- 输出: 功能列表。
- **解析逻辑**:
  - 从 `feature_limits` 获取所有功能定义。
  - 从 `user_feature_usage.usage_data` 中读取对应的 JSON 对象。
  - 检查 date: 如果 JSON 中的 date 不是今天 (UTC)，则视 `used` 为 0。
  - 否则使用 JSON 中的 `used`。

```sql
CREATE OR REPLACE FUNCTION get_user_quota_status()
RETURNS TABLE (
  feature_key TEXT,
  used_count INT,
  quota_limit INT,
  remaining INT,
  refresh_period TEXT
) AS $$
-- 实现细节 (关联 user_subscriptions, feature_limits 和 user_feature_usage)
$$ LANGUAGE plpgsql;
```

### 3.3 记录用量 (RPC)

为了安全地增加用量，前端通过调用安全的 RPC 函数而不是直接更新表。

**逻辑:**

- 输入: `feature_key`, `amount` (默认 1)
- 步骤:
  1. 获取当前 UTC 日期字符串 (iso_date)。
  2. 读取用户当行数据的 `usage_data -> feature_key`。
  3. 比较日期:
     - 记录日期 == 今日: `new_count = old_count + amount`
     - 记录日期 != 今日 (或不存在): `new_count = amount`
  4. 使用 `jsonb_set` 更新单一 Key，保持其他 Feature 数据不变。

```sql
CREATE OR REPLACE FUNCTION track_feature_usage(feature TEXT, amount INT DEFAULT 1)
RETURNS BOOLEAN AS $$
-- 实现细节
$$ LANGUAGE plpgsql;
```

### 3.4 配额重置机制 (Quota Reset Mechanism)

本系统采用 **“惰性重置 (Lazy Reset)”** 策略，而非传统的 Cron Job 主动重置。

**核心原理**:
我们不通过定时的后台任务来清零所有用户的配额，而是在用户**访问**（读取或写入用量）的那一刻，动态判断数据是否过期。

**工作流程**:

1.  **用户不活跃时**:
    - 即使到了 00:00，数据库中的数据保持不变（例如 `count: 10`, `period: "2026-01-24"`）。
    - **优势**: 节省大量数据库资源，避免处理无效数据。

2.  **用户调用时 (Lazy Check)**:
    - 用户发起 `track_feature_usage`。
    - 逻辑层获取 `Current Date (UTC)` ("2026-01-25")。
    - 逻辑层对比数据库中的 `period` ("2026-01-24")。
    - 发现 `period != Current Date`，判定为**已过期**。
    - 直接将新记录视为从 0 开始累计（即本次写入 `count = amount`），并将 `period` 更新为今天。

这种机制通过在业务逻辑中简单的字符串比对，替代了维护复杂且昂贵的系统级定时任务。

## 4. 安全性与 RLS

1.  **`feature_limits`**:
    - **Select**: 公开 (已认证用户可读取限制)。
    - **Insert/Update/Delete**: 仅限服务角色 (Service Role) 或管理员。
2.  **`user_feature_usage`**:
    - **Select**: 用户只能查看自己的用量 (`auth.uid() = user_id`)。
    - **Update**: **全员禁止**。更新必须通过 `track_feature_usage` RPC 进行，以确保逻辑一致性 (重置日期、检查上限)。

## 5. 前端集成计划

### 5.1 性能优化策略 (Optimistic UI)

为了避免每次操作都阻塞等待网络请求，前端将采用 **“本地乐观检查 + 异步同步”** 策略。

1.  **初始化 (Init)**:
    - App 启动时，调用 `get_user_quota_status` 一次性拉取最新的 Limit 和 Count，存入前端内存缓存 (`UsageService`).
2.  **本地检查 (Check)**:
    - 用户点击功能时，`FeatureGate` **仅检查本地缓存**。
    - 如果 `cache.count < cache.limit`，立即返回 `true`。**零延迟，不等待网络**。
3.  **异步同步 (Async Sync)**:
    - 在执行业务逻辑的同时，前端后台**异步**调用 `track_feature_usage` RPC。
    - 如果 RPC 成功：静默。
    - 如果 RPC 失败或返回“已超额”：在下一次操作或 UI 刷新时回滚本地状态或弹出提示。
4.  **兜底防护 (Hard Guard)**:
    - 真正的硬性拦截由后端的业务 API (Cloudflare Worker) 实现。API 在执行昂贵操作前会复核配额。前端检查主要用于**用户体验优化**。

### 5.2 开发任务

1.  **模型 (Models)**: 更新 `PaidFeature` 枚举以匹配数据库键名。
2.  **服务 (Service)**: 创建 `SupabaseUsageService` 实现 `UsageService` 接口。
    - 实现上述的缓存 + 异步同步逻辑。
3.  **FeatureGate**:
    - 更新 `getQuotaLimit` 以从获取的配置中读取。
    - 确保 Check 逻辑是非阻塞的。

## 6. 迁移步骤

1.  **创建迁移 SQL**:
    - 创建表。
    - 设置 RLS。
    - 创建函数 (RPCs) 和触发器。
    - 使用当前的生产环境值 (来自 `pricing_strategy.md`) 填充 `feature_limits`。
2.  **应用迁移**: 运行 `supabase db reset` 或推送迁移。
3.  **前端更新**: 切换 `UsageService` 的实现。

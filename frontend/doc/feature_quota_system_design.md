# 功能配额系统设计方案 (Feature Quota System Design)

## 1. 概述

本文档概述了服务端功能配额系统（Feature Gating & Quota Management）的技术设计。我们将不再在前端硬编码限制，而是由后端作为“单一事实来源 (Source of Truth)”来管理功能限制和使用情况追踪。

## 2. 数据库结构 (Database Schema)

我们将引入两张新表来分别管理“配置”和“用户状态”。

### 2.1 功能配置表 (`feature_limits`)

定义每个订阅等级 (Tier) 的规则和限制。这允许我们在不更新 App 的情况下动态调整策略。

```sql
CREATE TABLE feature_limits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tier TEXT NOT NULL CHECK (tier IN ('free', 'plus', 'pro')),
    feature_key TEXT NOT NULL,  -- 例如 'daily_conversation', 'voice_input', 'custom_scenarios'

    -- 配额数值: -1 代表无限，0 代表不可用，正整数代表具体限制数量
    quota_limit INTEGER NOT NULL DEFAULT 0,

    -- 刷新策略:
    -- 'daily': 每天 00:00 UTC 重置 (如 daily_conversation)
    -- 'static': 从不重置，终身累计 (如 custom_scenarios)
    refresh_period TEXT NOT NULL DEFAULT 'daily' CHECK (refresh_period IN ('daily', 'static')),

    -- 版本控制字段 (支持配额调整和限时活动)
    effective_from TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    effective_to TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,

    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- 同一时间段内，同一 tier + feature_key 只能有一个活跃配置
    CONSTRAINT unique_active_config UNIQUE (tier, feature_key, effective_from)
);
```

### 2.2 用户用量状态表 (`user_feature_usage`)

使用 **JSONB** 格式存储，确保每个用户在数据库中**只占一行**。

```sql
CREATE TABLE user_feature_usage (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,

    -- 存储所有功能的用量状态
    -- Key: feature_key
    -- Value:
    -- {
    --   "count": int,         // 当前周期已用量
    --   "period": string,     // 周期标识 ("YYYY-MM-DD" for daily, "lifetime" for static)
    --   "updated_at": bigint  // 时间戳 (ms)
    -- }
    --
    -- 示例:
    -- {
    --   "daily_conversation": {
    --     "count": 45,
    --     "period": "2026-01-25",        // daily 类型: 每天重置
    --     "updated_at": 1706164800000
    --   },
    --   "custom_scenarios": {
    --     "count": 8,
    --     "period": "lifetime",          // static 类型: 永久累计，不重置
    --     "updated_at": 1705800000000
    --   }
    -- }
    usage_data JSONB DEFAULT '{}'::jsonb,

    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

## 3. 业务逻辑 (服务端)

### 3.1 初始化 (Trigger)

当新用户注册时，我们需要初始化他们的用量记录。我们可以使用 `auth.users` 上的数据库触发器来实现。

```sql
-- 触发器函数
CREATE OR REPLACE FUNCTION handle_new_user_quotas()
RETURNS TRIGGER AS $$
BEGIN
  -- 插入一行空记录，确保后续可以直接 Update
  INSERT INTO user_feature_usage (user_id, usage_data)
  VALUES (NEW.id, '{}'::jsonb);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 触发器定义
CREATE TRIGGER on_auth_user_created_quotas
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user_quotas();
```

### 3.2 获取配额状态 (RPC)

前端需要获取“限制 vs 用量”的统一视图。我们使用 Postgres 函数 (RPC) 动态计算，并在读取时处理“每日重置”逻辑。

**逻辑:**

- 输入: `user_id` (默认为当前用户)
- 输出: 功能列表。
- **解析逻辑**:
  - 从 `feature_limits` 获取所有功能定义。
  - 从 `user_feature_usage.usage_data` 中读取对应的 JSON 对象。
  - 检查 date: 如果 JSON 中的 date 不是今天 (UTC)，则视 `used` 为 0。
  - 否则使用 JSON 中的 `used`。

```sql
CREATE OR REPLACE FUNCTION get_user_quota_status()
RETURNS TABLE (
  feature_key TEXT,
  used_count INT,
  quota_limit INT,
  remaining INT,
  refresh_period TEXT
) AS $$
DECLARE
  current_tier TEXT;
  current_date TEXT;
  usage_json JSONB;
BEGIN
  -- 1. 获取用户当前订阅等级 (默认 'free')
  SELECT COALESCE(us.tier, 'free')
  INTO current_tier
  FROM user_subscriptions us
  WHERE us.user_id = auth.uid()
  LIMIT 1;

  -- 如果没有订阅记录，默认为 free
  IF current_tier IS NULL THEN
    current_tier := 'free';
  END IF;

  -- 2. 获取今天的日期 (UTC)
  current_date := to_char(NOW() AT TIME ZONE 'UTC', 'YYYY-MM-DD');

  -- 3. 获取用户的 usage_data
  SELECT COALESCE(ufu.usage_data, '{}'::jsonb)
  INTO usage_json
  FROM user_feature_usage ufu
  WHERE ufu.user_id = auth.uid();

  -- 如果用户没有记录，初始化为空 JSONB
  IF usage_json IS NULL THEN
    usage_json := '{}'::jsonb;
  END IF;

  -- 4. 返回所有功能的配额状态 (根据当前活跃配置)
  RETURN QUERY
  SELECT
    fl.feature_key,
    -- 计算已用量：检查 period 是否匹配
    CASE
      -- Daily 类型：如果日期不匹配，视为新的一天，返回 0
      WHEN fl.refresh_period = 'daily'
           AND (usage_json -> fl.feature_key ->> 'period') != current_date
      THEN 0
      -- Static 类型 或 日期匹配：返回实际 count
      ELSE COALESCE((usage_json -> fl.feature_key ->> 'count')::INT, 0)
    END AS used_count,
    fl.quota_limit,
    -- 计算剩余量
    CASE
      WHEN fl.quota_limit = -1 THEN -1  -- 无限制
      WHEN fl.refresh_period = 'daily'
           AND (usage_json -> fl.feature_key ->> 'period') != current_date
      THEN fl.quota_limit  -- 新的一天，剩余 = 总额
      ELSE GREATEST(0, fl.quota_limit - COALESCE((usage_json -> fl.feature_key ->> 'count')::INT, 0))
    END AS remaining,
    fl.refresh_period
  FROM feature_limits fl
  WHERE fl.tier = current_tier
    AND fl.is_active = true  -- 只查询活跃的配置
    AND (fl.effective_to IS NULL OR fl.effective_to > NOW());  -- 未过期
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3.3 记录用量 (RPC)

为了安全地增加用量，前端通过调用安全的 RPC 函数而不是直接更新表。

**逻辑:**

- 输入: `feature_key`, `amount` (默认 1)
- 返回: `JSONB` - `{ "success": boolean, "remaining": int, "message": string }`
- 步骤:
  1. 获取当前 UTC 日期字符串或 "lifetime"（根据 refresh_period）。
  2. 读取配额限制（从 `feature_limits`）。
  3. 读取用户当前 `usage_data -> feature_key`。
  4. 比较日期/period:
     - 记录 period == 当前 period: `new_count = old_count + amount`
     - 记录 period != 当前 period (或不存在): `new_count = amount`
  5. **超额检查**: 如果 `quota_limit != -1 AND new_count > quota_limit`，返回失败。
  6. 使用 `jsonb_set` 更新单一 Key，保持其他 Feature 数据不变。
  7. 返回成功结果和剩余配额。

```sql
CREATE OR REPLACE FUNCTION track_feature_usage(
  feature TEXT,
  amount INT DEFAULT 1
)
RETURNS JSONB AS $$
DECLARE
  current_period TEXT;
  usage_json JSONB;
  current_count INT;
  quota_limit INT;
  refresh_period TEXT;
  new_count INT;
  remaining_quota INT;
  current_tier TEXT;
BEGIN
  -- 1. 获取用户当前订阅等级
  SELECT COALESCE(us.tier, 'free')
  INTO current_tier
  FROM user_subscriptions us
  WHERE us.user_id = auth.uid()
  LIMIT 1;

  IF current_tier IS NULL THEN
    current_tier := 'free';
  END IF;

  -- 2. 获取配额限制和刷新策略
  SELECT fl.quota_limit, fl.refresh_period
  INTO quota_limit, refresh_period
  FROM feature_limits fl
  WHERE fl.tier = current_tier
    AND fl.feature_key = feature
    AND fl.is_active = true
    AND (fl.effective_to IS NULL OR fl.effective_to > NOW())
  LIMIT 1;

  -- 如果找不到配置，返回错误
  IF quota_limit IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'remaining', 0,
      'message', 'Feature configuration not found'
    );
  END IF;

  -- 3. 确定当前 period
  IF refresh_period = 'daily' THEN
    current_period := to_char(NOW() AT TIME ZONE 'UTC', 'YYYY-MM-DD');
  ELSE
    current_period := 'lifetime';  -- static 类型
  END IF;

  -- 4. 获取当前用量数据
  SELECT COALESCE(ufu.usage_data, '{}'::jsonb)
  INTO usage_json
  FROM user_feature_usage ufu
  WHERE ufu.user_id = auth.uid();

  IF usage_json IS NULL THEN
    usage_json := '{}'::jsonb;
  END IF;

  -- 5. 计算新用量
  IF (usage_json -> feature ->> 'period') = current_period THEN
    -- 同一周期内，累加
    current_count := COALESCE((usage_json -> feature ->> 'count')::INT, 0);
    new_count := current_count + amount;
  ELSE
    -- 新周期（或首次使用），从 amount 开始
    new_count := amount;
  END IF;

  -- 6. 超额检查
  IF quota_limit != -1 AND new_count > quota_limit THEN
    RETURN jsonb_build_object(
      'success', false,
      'remaining', 0,
      'message', 'Quota exceeded'
    );
  END IF;

  -- 7. 更新记录
  UPDATE user_feature_usage
  SET
    usage_data = jsonb_set(
      usage_data,
      ARRAY[feature],
      jsonb_build_object(
        'count', new_count,
        'period', current_period,
        'updated_at', EXTRACT(EPOCH FROM NOW() AT TIME ZONE 'UTC')::BIGINT * 1000
      )
    ),
    updated_at = NOW()
  WHERE user_id = auth.uid();

  -- 如果用户记录不存在，插入一条新记录
  IF NOT FOUND THEN
    INSERT INTO user_feature_usage (user_id, usage_data)
    VALUES (
      auth.uid(),
      jsonb_build_object(
        feature,
        jsonb_build_object(
          'count', new_count,
          'period', current_period,
          'updated_at', EXTRACT(EPOCH FROM NOW() AT TIME ZONE 'UTC')::BIGINT * 1000
        )
      )
    );
  END IF;

  -- 8. 计算剩余配额
  IF quota_limit = -1 THEN
    remaining_quota := -1;
  ELSE
    remaining_quota := quota_limit - new_count;
  END IF;

  -- 9. 返回成功结果
  RETURN jsonb_build_object(
    'success', true,
    'remaining', remaining_quota,
    'message', 'Usage tracked successfully'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3.4 配额重置机制 (Quota Reset Mechanism)

本系统采用 **“惰性重置 (Lazy Reset)”** 策略，而非传统的 Cron Job 主动重置。

**核心原理**:
我们不通过定时的后台任务来清零所有用户的配额，而是在用户**访问**（读取或写入用量）的那一刻，动态判断数据是否过期。

**工作流程**:

1.  **用户不活跃时**:
    - 即使到了 00:00，数据库中的数据保持不变（例如 `count: 10`, `period: "2026-01-24"`）。
    - **优势**: 节省大量数据库资源，避免处理无效数据。

2.  **用户调用时 (Lazy Check)**:
    - 用户发起 `track_feature_usage`。
    - 逻辑层获取 `Current Date (UTC)` ("2026-01-25")。
    - 逻辑层对比数据库中的 `period` ("2026-01-24")。
    - 发现 `period != Current Date`，判定为**已过期**。
    - 直接将新记录视为从 0 开始累计（即本次写入 `count = amount`），并将 `period` 更新为今天。

这种机制通过在业务逻辑中简单的字符串比对，替代了维护复杂且昂贵的系统级定时任务。

## 4. 安全性与 RLS

1.  **`feature_limits`**:
    - **Select**: 公开 (已认证用户可读取限制)。
    - **Insert/Update/Delete**: 仅限服务角色 (Service Role) 或管理员。
2.  **`user_feature_usage`**:
    - **Select**: 用户只能查看自己的用量 (`auth.uid() = user_id`)。
    - **Update**: **全员禁止**。更新必须通过 `track_feature_usage` RPC 进行，以确保逻辑一致性 (重置日期、检查上限)。

## 5. 前端集成计划

### 5.1 性能优化策略 (Optimistic UI)

为了避免每次操作都阻塞等待网络请求，前端将采用 **“本地乐观检查 + 异步同步”** 策略。

1.  **初始化 (Init)**:
    - App 启动时，调用 `get_user_quota_status` 一次性拉取最新的 Limit 和 Count，存入前端内存缓存 (`UsageService`).
2.  **本地检查 (Check)**:
    - 用户点击功能时，`FeatureGate` **仅检查本地缓存**。
    - 如果 `cache.count < cache.limit`，立即返回 `true`。**零延迟，不等待网络**。
3.  **异步同步 (Async Sync)**:
    - 在执行业务逻辑的同时，前端后台**异步**调用 `track_feature_usage` RPC。
    - 如果 RPC 成功：静默。
    - 如果 RPC 失败或返回“已超额”：在下一次操作或 UI 刷新时回滚本地状态或弹出提示。
4.  **兜底防护 (Hard Guard)**:
    - 真正的硬性拦截由后端的业务 API (Cloudflare Worker) 实现。API 在执行昂贵操作前会复核配额。前端检查主要用于**用户体验优化**。

### 5.2 开发任务

1.  **模型 (Models)**: 更新 `PaidFeature` 枚举以匹配数据库键名。
2.  **服务 (Service)**: 创建 `SupabaseUsageService` 实现 `UsageService` 接口。
    - 实现上述的缓存 + 异步同步逻辑。
3.  **FeatureGate**:
    - 更新 `getQuotaLimit` 以从获取的配置中读取。
    - 确保 Check 逻辑是非阻塞的。

## 6. 迁移步骤

1.  **创建迁移 SQL**:
    - 创建表。
    - 设置 RLS。
    - 创建函数 (RPCs) 和触发器。
    - **插入初始配额配置 (Seed Data)**。
    - **为现有用户初始化配额记录**。
2.  **应用迁移**: 运行 `supabase db reset` 或推送迁移。
3.  **前端更新**: 切换 `UsageService` 的实现。

### 6.1 初始化数据 (Seed Data)

迁移 SQL 中需要包含以下初始配额配置：

```sql
-- ============================================
-- 插入默认配额配置 (基于 pricing_strategy.md)
-- ============================================
INSERT INTO feature_limits (tier, feature_key, quota_limit, refresh_period, is_active) VALUES
-- Free tier
('free', 'daily_conversation', 3, 'daily', true),
('free', 'voice_input', 3, 'daily', true),
('free', 'speech_assessment', 3, 'daily', true),
('free', 'word_pronunciation', 10, 'daily', true),
('free', 'grammar_analysis', 3, 'daily', true),
('free', 'tts_speak', 3, 'daily', true),
('free', 'custom_scenarios', 0, 'static', true),        -- Free 用户不能创建

-- Plus tier
('plus', 'daily_conversation', 20, 'daily', true),
('plus', 'voice_input', 20, 'daily', true),
('plus', 'speech_assessment', 20, 'daily', true),
('plus', 'word_pronunciation', -1, 'static', true),     -- 无限制
('plus', 'grammar_analysis', 20, 'daily', true),
('plus', 'tts_speak', 20, 'daily', true),
('plus', 'custom_scenarios', 10, 'static', true),       -- 终身 10 个

-- Pro tier
('pro', 'daily_conversation', 100, 'daily', true),
('pro', 'voice_input', 100, 'daily', true),
('pro', 'speech_assessment', 100, 'daily', true),
('pro', 'word_pronunciation', -1, 'static', true),      -- 无限制
('pro', 'grammar_analysis', 100, 'daily', true),
('pro', 'tts_speak', 100, 'daily', true),
('pro', 'custom_scenarios', 50, 'static', true);        -- 终身 50 个
```

### 6.2 现有用户初始化

为已存在的用户创建配额记录（触发器只对新用户生效）：

```sql
-- ============================================
-- 为现有用户初始化配额记录
-- ============================================
INSERT INTO user_feature_usage (user_id, usage_data)
SELECT id, '{}'::jsonb
FROM auth.users
WHERE NOT EXISTS (
  SELECT 1 FROM user_feature_usage
  WHERE user_feature_usage.user_id = auth.users.id
);
```

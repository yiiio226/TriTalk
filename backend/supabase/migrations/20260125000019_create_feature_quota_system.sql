-- ============================================
-- 功能配额系统 (Feature Quota System)
-- ============================================
-- 实现服务端功能配额管理，支持动态配置和用量追踪
-- 参考: frontend/doc/feature_quota_system_design.md

-- ============================================
-- 1. 创建表结构
-- ============================================

-- 1.1 功能配置表 (feature_limits)
-- 定义每个订阅等级的规则和限制
CREATE TABLE feature_limits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tier TEXT NOT NULL CHECK (tier IN ('free', 'plus', 'pro')),
    feature_key TEXT NOT NULL,  -- 例如 'daily_conversation', 'voice_input', 'custom_scenarios'

    -- 配额数值: -1 代表无限，0 代表不可用，正整数代表具体限制数量
    quota_limit INTEGER NOT NULL DEFAULT 0,

    -- 刷新策略:
    -- 'daily': 每天 00:00 UTC 重置 (如 daily_conversation)
    -- 'static': 从不重置，终身累计 (如 custom_scenarios)
    refresh_period TEXT NOT NULL DEFAULT 'daily' CHECK (refresh_period IN ('daily', 'static')),

    -- 版本控制字段 (支持配额调整和限时活动)
    effective_from TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    effective_to TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT true,

    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- 同一时间段内，同一 tier + feature_key 只能有一个活跃配置
    CONSTRAINT unique_active_config UNIQUE (tier, feature_key, effective_from)
);

-- 1.2 用户用量状态表 (user_feature_usage)
-- 使用 JSONB 格式存储，确保每个用户在数据库中只占一行
CREATE TABLE user_feature_usage (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,

    -- 存储所有功能的用量状态
    -- Key: feature_key
    -- Value:
    -- {
    --   "count": int,         // 当前周期已用量
    --   "period": string,     // 周期标识 ("YYYY-MM-DD" for daily, "lifetime" for static)
    --   "updated_at": bigint  // 时间戳 (ms)
    -- }
    --
    -- 示例:
    -- {
    --   "daily_conversation": {
    --     "count": 45,
    --     "period": "2026-01-25",        // daily 类型: 每天重置
    --     "updated_at": 1706164800000
    --   },
    --   "custom_scenarios": {
    --     "count": 8,
    --     "period": "lifetime",          // static 类型: 永久累计，不重置
    --     "updated_at": 1705800000000
    --   }
    -- }
    usage_data JSONB DEFAULT '{}'::jsonb,

    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 添加索引以优化查询性能
CREATE INDEX idx_feature_limits_tier_active ON feature_limits(tier, is_active) WHERE is_active = true;
CREATE INDEX idx_user_feature_usage_user_id ON user_feature_usage(user_id);

-- ============================================
-- 2. 创建触发器 - 新用户自动初始化配额
-- ============================================

-- 触发器函数
CREATE OR REPLACE FUNCTION handle_new_user_quotas()
RETURNS TRIGGER AS $$
BEGIN
  -- 插入一行空记录，确保后续可以直接 Update
  INSERT INTO user_feature_usage (user_id, usage_data)
  VALUES (NEW.id, '{}'::jsonb);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 触发器定义
CREATE TRIGGER on_auth_user_created_quotas
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user_quotas();

-- ============================================
-- 3. 创建 RPC 函数 - 获取配额状态
-- ============================================

CREATE OR REPLACE FUNCTION get_user_quota_status()
RETURNS TABLE (
  feature_key TEXT,
  used_count INT,
  quota_limit INT,
  remaining INT,
  refresh_period TEXT
) AS $$
DECLARE
  current_tier TEXT;
  today_date TEXT;
  usage_json JSONB;
BEGIN
  -- 1. 获取用户当前订阅等级 (默认 'free')
  SELECT COALESCE(us.tier, 'free')
  INTO current_tier
  FROM user_subscriptions us
  WHERE us.user_id = auth.uid()
  LIMIT 1;

  -- 如果没有订阅记录，默认为 free
  IF current_tier IS NULL THEN
    current_tier := 'free';
  END IF;

  -- 2. 获取今天的日期 (UTC)
  today_date := to_char(NOW() AT TIME ZONE 'UTC', 'YYYY-MM-DD');

  -- 3. 获取用户的 usage_data
  SELECT COALESCE(ufu.usage_data, '{}'::jsonb)
  INTO usage_json
  FROM user_feature_usage ufu
  WHERE ufu.user_id = auth.uid();

  -- 如果用户没有记录，初始化为空 JSONB
  IF usage_json IS NULL THEN
    usage_json := '{}'::jsonb;
  END IF;

  -- 4. 返回所有功能的配额状态 (根据当前活跃配置)
  RETURN QUERY
  SELECT
    fl.feature_key,
    -- 计算已用量：检查 period 是否匹配
    CASE
      -- Daily 类型：如果日期不匹配，视为新的一天，返回 0
      WHEN fl.refresh_period = 'daily'
           AND (usage_json -> fl.feature_key ->> 'period') != today_date
      THEN 0
      -- Static 类型 或 日期匹配：返回实际 count
      ELSE COALESCE((usage_json -> fl.feature_key ->> 'count')::INT, 0)
    END AS used_count,
    fl.quota_limit,
    -- 计算剩余量
    CASE
      WHEN fl.quota_limit = -1 THEN -1  -- 无限制
      WHEN fl.refresh_period = 'daily'
           AND (usage_json -> fl.feature_key ->> 'period') != today_date
      THEN fl.quota_limit  -- 新的一天，剩余 = 总额
      ELSE GREATEST(0, fl.quota_limit - COALESCE((usage_json -> fl.feature_key ->> 'count')::INT, 0))
    END AS remaining,
    fl.refresh_period
  FROM feature_limits fl
  WHERE fl.tier = current_tier
    AND fl.is_active = true  -- 只查询活跃的配置
    AND fl.effective_from <= NOW()
    AND (fl.effective_to IS NULL OR fl.effective_to > NOW());  -- 未过期
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 4. 创建 RPC 函数 - 记录用量
-- ============================================

CREATE OR REPLACE FUNCTION track_feature_usage(
  feature TEXT,
  amount INT DEFAULT 1
)
RETURNS JSONB AS $$
DECLARE
  current_period TEXT;
  usage_json JSONB;
  current_count INT;
  quota_limit INT;
  refresh_period TEXT;
  new_count INT;
  remaining_quota INT;
  current_tier TEXT;
BEGIN
  -- 1. 获取用户当前订阅等级
  SELECT COALESCE(us.tier, 'free')
  INTO current_tier
  FROM user_subscriptions us
  WHERE us.user_id = auth.uid()
  LIMIT 1;

  IF current_tier IS NULL THEN
    current_tier := 'free';
  END IF;

  -- 2. 获取配额限制和刷新策略
  SELECT fl.quota_limit, fl.refresh_period
  INTO quota_limit, refresh_period
  FROM feature_limits fl
  WHERE fl.tier = current_tier
    AND fl.feature_key = feature
    AND fl.is_active = true
    AND fl.effective_from <= NOW()
    AND (fl.effective_to IS NULL OR fl.effective_to > NOW())
  LIMIT 1;

  -- 如果找不到配置，返回错误
  IF quota_limit IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'remaining', 0,
      'message', 'Feature configuration not found'
    );
  END IF;

  -- 3. 确定当前 period
  IF refresh_period = 'daily' THEN
    current_period := to_char(NOW() AT TIME ZONE 'UTC', 'YYYY-MM-DD');
  ELSE
    current_period := 'lifetime';  -- static 类型
  END IF;

  -- 4. 锁定并获取当前用量数据 (Lock and Load)
  -- 确保记录存在，防止并发插入冲突
  INSERT INTO user_feature_usage (user_id, usage_data)
  VALUES (auth.uid(), '{}'::jsonb)
  ON CONFLICT (user_id) DO NOTHING;

  -- 锁定行以进行更新
  SELECT usage_data INTO usage_json
  FROM user_feature_usage
  WHERE user_id = auth.uid()
  FOR UPDATE;

  -- 理论上不应该为 NULL，但以防万一
  IF usage_json IS NULL THEN
    usage_json := '{}'::jsonb;
  END IF;

  -- 5. 计算新用量
  IF (usage_json -> feature ->> 'period') = current_period THEN
    -- 同一周期内，累加
    current_count := COALESCE((usage_json -> feature ->> 'count')::INT, 0);
    new_count := current_count + amount;
  ELSE
    -- 新周期（或首次使用），从 amount 开始
    new_count := amount;
  END IF;

  -- 6. 超额检查 - 关键：在持有锁的情况下检查
  IF quota_limit != -1 AND new_count > quota_limit THEN
    RETURN jsonb_build_object(
      'success', false,
      'remaining', 0,
      'message', 'Quota exceeded'
    );
  END IF;

  -- 7. 更新记录 (Update)
  UPDATE user_feature_usage
  SET
    usage_data = jsonb_set(
      usage_data,
      ARRAY[feature],
      jsonb_build_object(
        'count', new_count,
        'period', current_period,
        'updated_at', EXTRACT(EPOCH FROM NOW() AT TIME ZONE 'UTC')::BIGINT * 1000
      )
    ),
    updated_at = NOW()
  WHERE user_id = auth.uid();

  -- 8. 计算剩余配额
  IF quota_limit = -1 THEN
    remaining_quota := -1;
  ELSE
    remaining_quota := quota_limit - new_count;
  END IF;

  -- 9. 返回成功结果
  RETURN jsonb_build_object(
    'success', true,
    'remaining', remaining_quota,
    'message', 'Usage tracked successfully'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 5. 设置 RLS (Row Level Security)
-- ============================================

-- 5.1 feature_limits 表
ALTER TABLE feature_limits ENABLE ROW LEVEL SECURITY;

-- 已认证用户可以读取所有配额配置
CREATE POLICY "Authenticated users can view feature limits"
  ON feature_limits
  FOR SELECT
  TO authenticated
  USING (true);

-- 只有服务角色可以修改配额配置
CREATE POLICY "Only service role can modify feature limits"
  ON feature_limits
  FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- 5.2 user_feature_usage 表
ALTER TABLE user_feature_usage ENABLE ROW LEVEL SECURITY;

-- 用户只能查看自己的用量数据
CREATE POLICY "Users can view their own usage"
  ON user_feature_usage
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- 禁止直接修改用量数据，必须通过 RPC 函数
-- (不创建 INSERT/UPDATE/DELETE 策略，确保所有修改都通过 track_feature_usage)

-- ============================================
-- 6. 插入默认配额配置 (Seed Data)
-- ============================================
-- 基于 frontend/doc/pricing_strategy.md

INSERT INTO feature_limits (tier, feature_key, quota_limit, refresh_period, is_active) VALUES
-- Free tier
('free', 'daily_conversation', 3, 'daily', true),
('free', 'voice_input', 3, 'daily', true),
('free', 'speech_assessment', 3, 'daily', true),
('free', 'word_pronunciation', 10, 'daily', true),
('free', 'grammar_analysis', 3, 'daily', true),
('free', 'tts_speak', 3, 'daily', true),
('free', 'custom_scenarios', 0, 'static', true),        -- Free 用户不能创建

-- Plus tier
('plus', 'daily_conversation', 20, 'daily', true),
('plus', 'voice_input', 20, 'daily', true),
('plus', 'speech_assessment', 20, 'daily', true),
('plus', 'word_pronunciation', -1, 'static', true),     -- 无限制
('plus', 'grammar_analysis', 20, 'daily', true),
('plus', 'tts_speak', 20, 'daily', true),
('plus', 'custom_scenarios', 10, 'static', true),       -- 终身 10 个

-- Pro tier
('pro', 'daily_conversation', 100, 'daily', true),
('pro', 'voice_input', 100, 'daily', true),
('pro', 'speech_assessment', 100, 'daily', true),
('pro', 'word_pronunciation', -1, 'static', true),      -- 无限制
('pro', 'grammar_analysis', 100, 'daily', true),
('pro', 'tts_speak', 100, 'daily', true),
('pro', 'custom_scenarios', 50, 'static', true);        -- 终身 50 个

-- ============================================
-- 7. 为现有用户初始化配额记录
-- ============================================
-- 触发器只对新用户生效，需要为已存在的用户创建记录

INSERT INTO user_feature_usage (user_id, usage_data)
SELECT id, '{}'::jsonb
FROM auth.users
WHERE NOT EXISTS (
  SELECT 1 FROM user_feature_usage
  WHERE user_feature_usage.user_id = auth.users.id
);
